<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>swift on ksnowlv技术笔记</title>
    <link>https://ksnowlv.github.io/categories/swift/</link>
    <description>Recent content in swift on ksnowlv技术笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 26 Nov 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://ksnowlv.github.io/categories/swift/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>iOS视频播放-AVPlayer和AVPlayerLayer</title>
      <link>https://ksnowlv.github.io/post/2019-11-26-iosshi-pin-bo-fang-avplayer/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2019-11-26-iosshi-pin-bo-fang-avplayer/</guid>
      <description>本文计划使用AVPlayer和AVPlayerLayer播放视频，视频格式如下： m4v:MP4的特殊类型，MP4格式的高清；可包含字幕 mp4</description>
    </item>
    
    <item>
      <title>swift泛型</title>
      <link>https://ksnowlv.github.io/post/2019-05-16-swiftfan-xing/</link>
      <pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2019-05-16-swiftfan-xing/</guid>
      <description>/// 交换两个对象的值 /// /// - Parameters: /// - aValue: 对象a /// - bValue: 对象b func swapValues&amp;lt;T&amp;gt;(_ aValue: inout T, _ bValue: inout T) { let temp = aValue aValue = bValue bValue = temp } /// 栈模板 struct QStack&amp;lt;T&amp;gt; { var items = [T]() mutating func push(_ item: T) { items.append(item) } mutating func pop() -&amp;gt; T</description>
    </item>
    
    <item>
      <title>swift call c</title>
      <link>https://ksnowlv.github.io/post/2019-04-01-swift-call-c/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2019-04-01-swift-call-c/</guid>
      <description>如何在swift调整c代码呢？ swift通过工程的桥接文件，调用oc或c的相关代码!!! 1.创建c文件：test.h和test.c test.</description>
    </item>
    
    <item>
      <title>swift call c&#43;&#43;（二）</title>
      <link>https://ksnowlv.github.io/post/2019-04-01-swift-call-c-plus-plus-er/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2019-04-01-swift-call-c-plus-plus-er/</guid>
      <description>如何在swift调整c++代码呢？ swift通过工程的桥接文件，调用oc的代码，间接调用c++代码!!! 1.创建C++ Person类文件：P</description>
    </item>
    
    <item>
      <title>swift call c&#43;&#43;（一）</title>
      <link>https://ksnowlv.github.io/post/2019-04-01-swift-call-c-plus-plus-yi/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2019-04-01-swift-call-c-plus-plus-yi/</guid>
      <description>如何在swift调整c++代码呢？ swift通过工程的桥接文件，调用c的代码，间接调用c++代码!!! 1.创建C++ Person类文件：Pe</description>
    </item>
    
    <item>
      <title>swift中pthread_t之mutex</title>
      <link>https://ksnowlv.github.io/post/2018-08-07-swiftzhong-pthread-tzhi-mutex/</link>
      <pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-08-07-swiftzhong-pthread-tzhi-mutex/</guid>
      <description>mutex类型有四种 PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_ERRORCHECK PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_DEFAULT 1.mutex初始化。 var mutex = pthread_mutex_t() var attr: pthread_mutexattr_t = pthread_mutexattr_t() pthread_mutexattr_init(&amp;amp;attr) pthread_mutexattr_settype(&amp;amp;attr, PTHREAD_MUTEX_RECURSIVE) pthread_mutex_init(&amp;amp;mutex, &amp;amp;attr) 2.mutex使用。```objective-c pthread_mutex_trylock(&amp;amp;mutex) //执行代码</description>
    </item>
    
    <item>
      <title>synchronized到objc_sync_enter/objc_sync_exit</title>
      <link>https://ksnowlv.github.io/post/2018-08-07-swiftzhong-yu-oczhong-yong-fa-qu-bie/</link>
      <pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-08-07-swiftzhong-yu-oczhong-yong-fa-qu-bie/</guid>
      <description>synchronized-&amp;gt;objc_sync_enter/objc_sync_exit objc_sync_enter：递归锁，与objc_sync_exit配合使用，注意死锁 Begin synchronizing on &amp;lsquo;obj&amp;rsquo;. Allocates recursive pthread_mutex associated with &amp;lsquo;obj&amp;rsquo; if needed. Parameters obj The object to begin synchronizing on. Returns OBJC_SYNC_SUCCESS once lock is</description>
    </item>
    
    <item>
      <title>全局并发队列优先级</title>
      <link>https://ksnowlv.github.io/post/2018-07-24-quan-ju-bing-fa-dui-lie-you-xian-ji/</link>
      <pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-24-quan-ju-bing-fa-dui-lie-you-xian-ji/</guid>
      <description>全局并发队（Global Queue） 老版gcd有四种：high，default，low，background， 优先级为：high&amp;gt;de</description>
    </item>
    
    <item>
      <title>swift-ecdh</title>
      <link>https://ksnowlv.github.io/post/2018-07-20-swift-ecdh/</link>
      <pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-20-swift-ecdh/</guid>
      <description>swift 在iOS10之后，支持ecdh加解密。 1.生成公钥和私钥。```objective-c func generateKey() { let attributes: [String: Any] = [kSecAttrKeySizeInBits as String: 256, kSecAttrKeyType as String: kSecAttrKeyTypeEC, kSecPrivateKeyAttrs as String: [kSecAttrIsPermanent as String: false]] var error: Unmanaged&amp;lt;CFError&amp;gt;?</description>
    </item>
    
    <item>
      <title>swift-rsa(四)-OAEP模式</title>
      <link>https://ksnowlv.github.io/post/2018-07-19-swift-rsa-4/</link>
      <pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-19-swift-rsa-4/</guid>
      <description>swift进行RSA加解密时，如果使用 OAEP时，有什么区别？ 1.RSA加密```objective-c @objc public func encrypt(source: String, padding: SecPadding = SecPadding.PKCS1) -&amp;gt; String { guard source.count &amp;gt; 0 &amp;amp;&amp;amp; self.publicSecKey</description>
    </item>
    
    <item>
      <title>swift-RSA(五)-签名/验签</title>
      <link>https://ksnowlv.github.io/post/2018-07-19-swift-rsa-5/</link>
      <pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-19-swift-rsa-5/</guid>
      <description>RSA支持加解密，也支持签名/验签。 使用rsa如何签名/验签呢？ 1.rsa 签名 @objc public func sign(source: Data, padding: SecPadding = SecPadding.PKCS1SHA1) -&amp;gt; Data? { guard source.count &amp;gt; 0 &amp;amp;&amp;amp; self.privateSecKey != nil else { return nil } let hashData: NSData? switch padding { case SecPadding.PKCS1SHA1: hashData =</description>
    </item>
    
    <item>
      <title>swift-class与struct区别</title>
      <link>https://ksnowlv.github.io/post/2018-07-18-swift-classyu-structqu-bie/</link>
      <pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-18-swift-classyu-structqu-bie/</guid>
      <description>比较项 struct class 类型 值类型 引用类型 属性初始化 可用默认构造直接初始化 需要自己创建构造方法 变量赋值 深拷贝 浅拷贝，增加原对象引用 方法中修改属性 需要添加m</description>
    </item>
    
    <item>
      <title>swift-https的支持</title>
      <link>https://ksnowlv.github.io/post/2018-07-18-swift-httpsde-zhi-chi/</link>
      <pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-18-swift-httpsde-zhi-chi/</guid>
      <description>swift中，如何支持https呢？ https分为单向（客户端校验服务端）的和双向（客户端/服务端相互校验）具体可查阅相关资料。 实现URLS</description>
    </item>
    
    <item>
      <title>swift-rsa(二)-SecKeyEncrypt errSecParam(-50)  </title>
      <link>https://ksnowlv.github.io/post/2018-07-18-swift-rsa-2/</link>
      <pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-18-swift-rsa-2/</guid>
      <description>swift中，使用SecKeyEncrypt进行RSA加密时，会出现errSecParam(-50)? 如何解决呢？ 按照苹果官方文档中的err</description>
    </item>
    
    <item>
      <title>swift-rsa(三)-大数据块加解密</title>
      <link>https://ksnowlv.github.io/post/2018-07-18-swift-rsa-3/</link>
      <pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-18-swift-rsa-3/</guid>
      <description>如何使用swift进行RSA大数据块加解密呢？ 1.使用RSA加密```objective-c @objc public func encrypt(source: String) -&amp;gt; String { guard source.count &amp;gt; 0 &amp;amp;&amp;amp; self.publicSecKey != nil else { return &amp;quot;&amp;quot; } let data: NSData</description>
    </item>
    
    <item>
      <title>swift-RSA(一)</title>
      <link>https://ksnowlv.github.io/post/2018-07-17-swift-rsa-1/</link>
      <pubDate>Tue, 17 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-17-swift-rsa-1/</guid>
      <description>如何使用swift进行RSA加解密呢？ 一.这四个方面:加载公钥/加载私钥/RSA加密/RSA解密 1.加载公钥 @objc public func publicKey(fileFullPath: NSString, block :@escaping YKRSASignBlock ) { if !FileManager.default.fileExists(atPath: fileFullPath as String){ block(NSError.init(domain:</description>
    </item>
    
    <item>
      <title>swift中escaping与noescaping之区别</title>
      <link>https://ksnowlv.github.io/post/2018-07-16-swift-escaping/</link>
      <pubDate>Mon, 16 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-16-swift-escaping/</guid>
      <description>Swift3之前： 默认escaping，逃逸闭包，是不安全的。对于非逃逸闭包，你需要标记@noescaping Swift3及之后 默认是noe</description>
    </item>
    
    <item>
      <title>NS_SWIFT_NAME与@objc区别与用途</title>
      <link>https://ksnowlv.github.io/post/2018-07-06-cf-swift-nameyu-at-objc/</link>
      <pubDate>Fri, 06 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-06-cf-swift-nameyu-at-objc/</guid>
      <description>NS_SWIFT_NAME与@objc有什么区别和用途呢？ NS_SWIFT_NAME :在objective-c中，重新命名在swift中的名称 @objc 在swift中，重新</description>
    </item>
    
    <item>
      <title>swift-cocoaframework中module.map配置</title>
      <link>https://ksnowlv.github.io/post/2018-07-04-swift-cocoaframeworkzhong-module-dot-mappei-zhi/</link>
      <pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-04-swift-cocoaframeworkzhong-module-dot-mappei-zhi/</guid>
      <description>在swift framework中，如果要引用c库，可采用配置module.map. 那如何配置呢？我们以CommonCrypto为例。 一.工程</description>
    </item>
    
    <item>
      <title>swift-framework的合并</title>
      <link>https://ksnowlv.github.io/post/2018-07-04-swift-frameworkde-he-bing/</link>
      <pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-04-swift-frameworkde-he-bing/</guid>
      <description>swift framework如何支持合并呢？以YKBaseFramework.framework为例。 1.lipo合并静态库。 lipo -create Release-iphoneos/YKBaseFramework.framework/YKBaseFramework Debug-iphonesimulator/YKBaseFramework.framework/YKBaseFramework -output YKBaseFramework 生成YKB</description>
    </item>
    
  </channel>
</rss>
