<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>安全 on ksnowlv技术笔记</title>
    <link>https://ksnowlv.github.io/tags/%E5%AE%89%E5%85%A8/</link>
    <description>Recent content in 安全 on ksnowlv技术笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 20 Jul 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://ksnowlv.github.io/tags/%E5%AE%89%E5%85%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>swift-ecdh</title>
      <link>https://ksnowlv.github.io/post/2018-07-20-swift-ecdh/</link>
      <pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-20-swift-ecdh/</guid>
      <description>swift 在iOS10之后，支持ecdh加解密。 1.生成公钥和私钥 func generateKey() { let attributes: [String: Any] = [kSecAttrKeySizeInBits as String: 256, kSecAttrKeyType as String: kSecAttrKeyTypeEC, kSecPrivateKeyAttrs as String: [kSecAttrIsPermanent as String: false]] var error: Unmanaged&amp;lt;CFError&amp;gt;? self.privateKey = SecKeyCreateRandomKey(attributes as CFDictionary, &amp;amp;error) if self.privateKey != nil { self.publicKey = SecKeyCopyPublicKey(self.privateKey!) }</description>
    </item>
    
    <item>
      <title>swift-rsa(四)-OAEP模式</title>
      <link>https://ksnowlv.github.io/post/2018-07-19-swift-rsa-4/</link>
      <pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-19-swift-rsa-4/</guid>
      <description>swift进行RSA加解密时，如果使用 OAEP时，有什么区别？ 1.RSA加密 @objc public func encrypt(source: String, padding: SecPadding = SecPadding.PKCS1) -&amp;gt; String { guard source.count &amp;gt; 0 &amp;amp;&amp;amp; self.publicSecKey != nil else { return &amp;#34;&amp;#34; } let data: NSData = (source.data(using: String.Encoding.utf8)! as</description>
    </item>
    
    <item>
      <title>swift-RSA(五)-签名/验签</title>
      <link>https://ksnowlv.github.io/post/2018-07-19-swift-rsa-5/</link>
      <pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-19-swift-rsa-5/</guid>
      <description>RSA支持加解密，也支持签名/验签。 使用rsa如何签名/验签呢？ 1.rsa 签名 @objc public func sign(source: Data, padding: SecPadding = SecPadding.PKCS1SHA1) -&amp;gt; Data? { guard source.count &amp;gt; 0 &amp;amp;&amp;amp; self.privateSecKey != nil else { return nil } let hashData: NSData? switch padding { case SecPadding.PKCS1SHA1: hashData =</description>
    </item>
    
    <item>
      <title>swift-https的支持</title>
      <link>https://ksnowlv.github.io/post/2018-07-18-swift-httpsde-zhi-chi/</link>
      <pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-18-swift-httpsde-zhi-chi/</guid>
      <description>swift中，如何支持https呢？ https分为单向（客户端校验服务端）的和双向（客户端/服务端相互校验）具体可查阅相关资料。 实现URLS</description>
    </item>
    
    <item>
      <title>swift-rsa(二)-SecKeyEncrypt errSecParam(-50)  </title>
      <link>https://ksnowlv.github.io/post/2018-07-18-swift-rsa-2/</link>
      <pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-18-swift-rsa-2/</guid>
      <description>swift中，使用SecKeyEncrypt进行RSA加密时，会出现errSecParam(-50)? 如何解决呢？ 按照苹果官方文档中的err</description>
    </item>
    
    <item>
      <title>swift-rsa(三)-大数据块加解密</title>
      <link>https://ksnowlv.github.io/post/2018-07-18-swift-rsa-3/</link>
      <pubDate>Wed, 18 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-18-swift-rsa-3/</guid>
      <description>如何使用swift进行RSA大数据块加解密呢？ 1.使用RSA加密 @objc public func encrypt(source: String) -&amp;gt; String { guard source.count &amp;gt; 0 &amp;amp;&amp;amp; self.publicSecKey != nil else { return &amp;#34;&amp;#34; } let data: NSData = (source.data(using: String.Encoding.utf8)! as NSData) /* if #available(iOS 10.0, *) { var error: Unmanaged&amp;lt;CFError&amp;gt;?</description>
    </item>
    
    <item>
      <title>swift-RSA(一)</title>
      <link>https://ksnowlv.github.io/post/2018-07-17-swift-rsa-1/</link>
      <pubDate>Tue, 17 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-07-17-swift-rsa-1/</guid>
      <description>如何使用swift进行RSA加解密呢？ 一.加载公钥/加载私钥/RSA加密/RSA解密 1.加载公钥 @objc public func publicKey(fileFullPath: NSString, block :@escaping YKRSASignBlock ) { if !FileManager.default.fileExists(atPath: fileFullPath as String){ block(NSError.init(domain: &amp;#34;file not exist at the full</description>
    </item>
    
    <item>
      <title>swift-散列算法md5</title>
      <link>https://ksnowlv.github.io/post/2018-06-22-swift-san-lie-suan-fa-md5/</link>
      <pubDate>Fri, 22 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-06-22-swift-san-lie-suan-fa-md5/</guid>
      <description>md5算法 swift中散列算法md5很常用。 func md5() -&amp;gt; NSString { guard self.length &amp;gt; 0 else { return self } let utf8Buf = self.cString(using: String.Encoding.utf8.rawValue) let length = self.lengthOfBytes(using: String.Encoding.utf8.rawValue) let buffer = UnsafeMutablePointer&amp;lt;CUnsignedChar&amp;gt;.allocate(capacity: Int(CC_MD5_DIGEST_LENGTH)) buffer.initialize(to: 0) CC_MD5(utf8Buf,CC_LONG(length), buffer) let md5String = NSMutableString() for i in 0 ..&amp;lt; CC_MD5_DIGEST_LENGTH { md5String.appendFormat(&amp;#34;%02x&amp;#34;, buffer[Int(i)]) } buffer.deallocate()</description>
    </item>
    
    <item>
      <title>非对称加解密算法之DSA-iOS中的应用</title>
      <link>https://ksnowlv.github.io/post/2018-04-20-fei-dui-cheng-jia-jie-mi-suan-fa-zhi-dsa-ioszhong-de-ying-yong/</link>
      <pubDate>Fri, 20 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-04-20-fei-dui-cheng-jia-jie-mi-suan-fa-zhi-dsa-ioszhong-de-ying-yong/</guid>
      <description>1.引用openssl库 https://github.com/x2on/OpenSSL-for-iPhone 2.对数据进行签名 /*对数据进行签名 @param data 要签名的数据 @return 签名后数据 */ - (NSData *)sign:(NSData *)data { int dsaSize = DSA_size(_privateDSAKey); unsigned char *signBuf = (unsigned char *)calloc(dsaSize, 1); memset(signBuf, 0, dsaSize *sizeof(unsigned char)); unsigned int</description>
    </item>
    
    <item>
      <title>非对称加解密算法之ECC</title>
      <link>https://ksnowlv.github.io/post/2018-04-20-fei-dui-cheng-jia-jie-mi-suan-fa-zhi-ecc/</link>
      <pubDate>Fri, 20 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-04-20-fei-dui-cheng-jia-jie-mi-suan-fa-zhi-ecc/</guid>
      <description>ECC算法用途比RSA还厉害。 支持加解密。 支持签名验证。 支持与DH结合使用，用于密钥磋商，这个密钥交换算法称为ECDH。 * 交换双方可以在不共</description>
    </item>
    
    <item>
      <title>常见非对称加密算法</title>
      <link>https://ksnowlv.github.io/post/2018-04-19-chang-jian-fei-dui-cheng-jia-mi-suan-fa/</link>
      <pubDate>Thu, 19 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-04-19-chang-jian-fei-dui-cheng-jia-mi-suan-fa/</guid>
      <description>常见非对称加密算法有哪些呢？ 1.RSA。 2.DSA。 3.ECC/ECDH/ECDSA。 4.Elgamal：Elgamal算法 5.背包算法： 对</description>
    </item>
    
    <item>
      <title>常见散列算法</title>
      <link>https://ksnowlv.github.io/post/2018-04-17-ioszhong-san-lie-suan-fa/</link>
      <pubDate>Tue, 17 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-04-17-ioszhong-san-lie-suan-fa/</guid>
      <description>散列算法 常见的单向散列算法，可用于数字签名，单向的，不可逆向，并非加密算法。 主要用途是为了校验数据在传输过程中是否被修改。 1.MD5(Message Digest algorithm 5，信息摘要</description>
    </item>
    
    <item>
      <title>非对称加解密算法之DSA---dsa公钥与私钥 </title>
      <link>https://ksnowlv.github.io/post/2018-04-17-fei-dui-cheng-jia-jie-mi-suan-fa-zhi-dsa-zhi-yi/</link>
      <pubDate>Tue, 17 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-04-17-fei-dui-cheng-jia-jie-mi-suan-fa-zhi-dsa-zhi-yi/</guid>
      <description>DSA(Digital Signature Algorithm)：非对称加密算法，安全性与RSA相比差不多。 DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行</description>
    </item>
    
    <item>
      <title>非对称加解密算法之DSA---dsa公钥与私钥 </title>
      <link>https://ksnowlv.github.io/post/2018-04-18-fei-dui-cheng-jia-jie-mi-suan-fa-zhi-dsa-zhi-yi/</link>
      <pubDate>Tue, 17 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2018-04-18-fei-dui-cheng-jia-jie-mi-suan-fa-zhi-dsa-zhi-yi/</guid>
      <description>DSA(Digital Signature Algorithm)：非对称加密算法，安全性与RSA相比差不多。 DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行</description>
    </item>
    
    <item>
      <title>加解密之3DES</title>
      <link>https://ksnowlv.github.io/post/2013-04-22-jia-jie-mi-zhi-3des/</link>
      <pubDate>Mon, 22 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2013-04-22-jia-jie-mi-zhi-3des/</guid>
      <description>iPhone 3DES iPhone开发过程中，可能会用到加解密之类的，这里使用iPhone SDK自带的加密接口。主要是针对3DES方式下的加解密。 1. 示例代码 加</description>
    </item>
    
    <item>
      <title>加解密之AES256</title>
      <link>https://ksnowlv.github.io/post/2013-04-22-jia-jie-mi-zhi-aes256/</link>
      <pubDate>Mon, 22 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2013-04-22-jia-jie-mi-zhi-aes256/</guid>
      <description>iPhone AES iPhone开发过程中，可能会用到加解密之类的，这里使用iPhone SDK自带的加密接口。主要是针对AES256方式下的加解密。 代码示例</description>
    </item>
    
    <item>
      <title>加解密之RC4</title>
      <link>https://ksnowlv.github.io/post/2013-04-22-jia-jie-mi-zhi-rc4/</link>
      <pubDate>Mon, 22 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>https://ksnowlv.github.io/post/2013-04-22-jia-jie-mi-zhi-rc4/</guid>
      <description>iPhone RC4 iPhone开发过程中，可能会用到加解密之类的，这里使用iPhone SDK自带的加密接口。主要是针对RC4方式下的加解密。 示例代码 // // ViewController.m</description>
    </item>
    
  </channel>
</rss>
